from __future__ import annotations

import asyncio
import logging
import json
import tempfile
from pathlib import Path
from typing import Dict, List
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, KeyboardButton
from telegram.constants import ParseMode
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, CallbackQueryHandler, ContextTypes, filters

from services.config import settings, assert_required_settings
from services.logging import setup_logging
from db.database import engine, session_scope
from db.models import Base
from db import repo
from services.categories import build_categories
from services.openrouter_client import chat_completion, OpenRouterError
from services.asr_whisper import transcribe_audio, ASRUnavailable

# In-memory store of last bot messages per chat for cleanup
_ephemeral_messages: Dict[int, List[int]] = {}


async def on_startup() -> None:
	if settings.feature_db:
		Base.metadata.create_all(bind=engine)


async def _cleanup_chat_messages(context: ContextTypes.DEFAULT_TYPE, chat_id: int) -> None:
	msg_ids = _ephemeral_messages.get(chat_id) or []
	if not msg_ids:
		return
	for mid in msg_ids:
		try:
			await context.bot.delete_message(chat_id=chat_id, message_id=mid)
		except Exception:
			pass
	_ephemeral_messages[chat_id] = []


async def _send_ephemeral(update: Update, context: ContextTypes.DEFAULT_TYPE, text: str, reply_markup: InlineKeyboardMarkup | None = None) -> None:
	chat_id = update.effective_chat.id
	await _cleanup_chat_messages(context, chat_id)
	sent = await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
	_ephemeral_messages.setdefault(chat_id, []).append(sent.message_id)


def _main_reply_kb() -> ReplyKeyboardMarkup:
	return ReplyKeyboardMarkup(
		[[KeyboardButton(text="ğŸ“‹ ĞœĞµĞ½Ñ")]],
		resize_keyboard=True,
		one_time_keyboard=False,
	)


def _main_menu_kb() -> InlineKeyboardMarkup:
	return InlineKeyboardMarkup(
		[
			[InlineKeyboardButton(text="ğŸ‘¤ Ğ›Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ ĞºĞ°Ğ±Ğ¸Ğ½ĞµÑ‚", callback_data="menu_profile")],
			[InlineKeyboardButton(text="ğŸ‹ï¸ Ğ¢Ñ€ĞµĞ½Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸", callback_data="menu_workouts")],
			[InlineKeyboardButton(text="ğŸ“… ĞœĞµĞ½Ñ Ğ½ĞµĞ´ĞµĞ»Ñ", callback_data="menu_week")],
			[InlineKeyboardButton(text="ğŸ¤– AI ĞšĞ‘Ğ–Ğ£ Ğ¿Ğ¾ Ñ„Ğ¾Ñ‚Ğ¾", callback_data="menu_ai_kbzhu_photo")],
			[InlineKeyboardButton(text="ğŸ†˜ ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ°", callback_data="menu_support")],
			[InlineKeyboardButton(text="ğŸ Ğ‘Ğ¾Ğ½ÑƒÑĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ°", callback_data="menu_loyalty")],
		]
	)


async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	await _send_ephemeral(update, context, "ĞœĞµĞ½Ñ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¾. Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°Ğ¹ Ñ€Ğ°Ğ·Ğ´ĞµĞ» ğŸ‘‡", reply_markup=_main_menu_kb())


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	if settings.feature_db:
		with session_scope() as s:
			user = repo.get_or_create_user(
				s,
				tg_user_id=str(update.effective_user.id),
				username=update.effective_user.username,
				first_name=update.effective_user.first_name,
				last_name=update.effective_user.last_name,
			)
			seen = repo.get_user_pref(s, user, "start_seen", False)
			if not seen:
				repo.set_user_pref(s, user, "start_seen", True)
				await _cleanup_chat_messages(context, update.effective_chat.id)
				await context.bot.send_message(
					chat_id=update.effective_chat.id,
					text="Ğ”Ğ¾Ğ±Ñ€Ğ¾ Ğ¿Ğ¾Ğ¶Ğ°Ğ»Ğ¾Ğ²Ğ°Ñ‚ÑŒ! ĞĞ°Ğ¶Ğ¼Ğ¸ <b>ğŸ“‹ ĞœĞµĞ½Ñ</b>, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ñ‹.",
					parse_mode=ParseMode.HTML,
					reply_markup=_main_reply_kb(),
				)
				return
	# fallback or repeated /start
	await _cleanup_chat_messages(context, update.effective_chat.id)
	await context.bot.send_message(
		chat_id=update.effective_chat.id,
		text="ĞĞ°Ğ¶Ğ¼Ğ¸ <b>ğŸ“‹ ĞœĞµĞ½Ñ</b>, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ñ‹.",
		parse_mode=ParseMode.HTML,
		reply_markup=_main_reply_kb(),
	)


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	await _send_ephemeral(update, context, "ĞŸĞ¾Ğ´ÑĞºĞ°Ğ·ĞºĞ°: Ğ½Ğ°Ğ¶Ğ¼Ğ¸ <b>ğŸ“‹ ĞœĞµĞ½Ñ</b> Ğ²Ğ½Ğ¸Ğ·Ñƒ, Ñ‡Ñ‚Ğ¾Ğ±Ñ‹ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ Ñ€Ğ°Ğ·Ğ´ĞµĞ»Ñ‹.")


async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	if not update.message or not update.message.text:
		return
	user_text = update.message.text.strip()

	# Open menu when user taps the persistent button
	if user_text.lower() in {"ğŸ“‹ Ğ¼ĞµĞ½Ñ", "Ğ¼ĞµĞ½Ñ", "/menu", "menu"}:
		await show_main_menu(update, context)
		return

	if settings.feature_db:
		with session_scope() as s:
			user = repo.get_or_create_user(
				s,
				tg_user_id=str(update.effective_user.id),
				username=update.effective_user.username,
				first_name=update.effective_user.first_name,
				last_name=update.effective_user.last_name,
			)
			repo.add_message(s, user_id=user.id, direction="in", type_="text", content=user_text)
			categories = build_categories(user)
			categories_json = json.dumps(categories, ensure_ascii=False)
	else:
		user = None
		categories = build_categories(None)
		categories_json = json.dumps(categories, ensure_ascii=False)

	reply_text = "ĞŸÑ€Ğ¸Ğ½ÑĞ»! ĞĞ°Ğ¶Ğ¼Ğ¸ <b>ğŸ“‹ ĞœĞµĞ½Ñ</b> Ğ´Ğ»Ñ Ğ½Ğ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ğ¸."
	if settings.feature_llm:
		try:
			reply_text, usage = await chat_completion(categories, user_text)
			if settings.feature_db and user:
				with session_scope() as s:
					repo.add_llm_exchange(
						s,
						user_id=user.id,
						provider="openrouter",
						model=settings.openrouter_model,
						prompt=user_text,
						categories_json=categories_json,
						response_text=reply_text,
						usage=usage,
					)
		except OpenRouterError as e:
			reply_text = "Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¹ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¿Ğ¾Ğ·Ğ¶Ğµ ğŸ™"
			logging.getLogger("llm").error("OpenRouter error: %s", e)

	await _send_ephemeral(update, context, reply_text)

	if settings.feature_db:
		with session_scope() as s2:
			user2 = repo.get_or_create_user(
				s2,
				tg_user_id=str(update.effective_user.id),
				username=update.effective_user.username,
				first_name=update.effective_user.first_name,
				last_name=update.effective_user.last_name,
			)
			repo.add_message(s2, user_id=user2.id, direction="out", type_="text", content=reply_text)


async def handle_voice(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	if not update.message or not update.message.voice:
		return

	if not settings.feature_asr:
		await _send_ephemeral(update, context, "Ğ“Ğ¾Ğ»Ğ¾Ñ Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ğ¿Ğ¾Ğ´ĞºĞ»ÑÑ‡Ñ‘Ğ½. ĞÑ‚Ğ¿Ñ€Ğ°Ğ²ÑŒ Ñ‚ĞµĞºÑÑ‚ âœï¸")
		return

	voice = update.message.voice
	with tempfile.TemporaryDirectory() as td:
		dl_path = Path(td) / f"{voice.file_unique_id}.oga"
		try:
			file = await context.bot.get_file(voice.file_id)
			await file.download_to_drive(custom_path=str(dl_path))
		except Exception as e:
			logging.getLogger("download").error("Failed to download voice: %s", e)
			await _send_ephemeral(update, context, "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ ÑĞºĞ°Ñ‡Ğ°Ñ‚ÑŒ Ğ³Ğ¾Ğ»Ğ¾ÑĞ¾Ğ²Ğ¾Ğµ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· ğŸ™")
			return
		try:
			text, _conf = await transcribe_audio(dl_path)
		except ASRUnavailable:
			await _send_ephemeral(update, context, "ASR Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½. Ğ”Ğ¾Ğ±Ğ°Ğ²ÑŒ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ¼, Ğ¿Ğ¾Ğ¶Ğ°Ğ»ÑƒĞ¹ÑÑ‚Ğ° ğŸ™")
			return
		except Exception as e:
			logging.getLogger("asr").error("Whisper failed: %s", e)
			await _send_ephemeral(update, context, "ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ñ€Ğ°ÑĞ¿Ğ¾Ğ·Ğ½Ğ°Ñ‚ÑŒ Ğ³Ğ¾Ğ»Ğ¾Ñ. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· ğŸ™")
			return

	user = None
	if settings.feature_db:
		with session_scope() as s:
			user = repo.get_or_create_user(
				s,
				tg_user_id=str(update.effective_user.id),
				username=update.effective_user.username,
				first_name=update.effective_user.first_name,
				last_name=update.effective_user.last_name,
			)
			repo.add_message(s, user_id=user.id, direction="in", type_="voice", content=text)
			repo.add_transcription(s, user_id=user.id, telegram_file_id=voice.file_id, text=text, audio_duration_sec=voice.duration, format_=voice.mime_type)

	categories = build_categories(user if settings.feature_db else None)
	categories_json = json.dumps(categories, ensure_ascii=False)
	reply_text = text
	if settings.feature_llm:
		try:
			reply_text, usage = await chat_completion(categories, text)
			if settings.feature_db and user:
				with session_scope() as s:
					repo.add_llm_exchange(
						s,
						user_id=user.id,
						provider="openrouter",
						model=settings.openrouter_model,
						prompt=text,
						categories_json=categories_json,
						response_text=reply_text,
						usage=usage,
					)
		except OpenRouterError as e:
			reply_text = "Ğ¡ĞµÑ€Ğ²Ğ¸Ñ Ñ€ĞµĞºĞ¾Ğ¼ĞµĞ½Ğ´Ğ°Ñ†Ğ¸Ğ¹ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ğ¾ Ğ½ĞµĞ´Ğ¾ÑÑ‚ÑƒĞ¿ĞµĞ½. ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹ ĞµÑ‰Ñ‘ Ñ€Ğ°Ğ· Ğ¿Ğ¾Ğ·Ğ¶Ğµ ğŸ™"
			logging.getLogger("llm").error("OpenRouter error: %s", e)

	await _send_ephemeral(update, context, reply_text)

	if settings.feature_db:
		with session_scope() as s2:
			user2 = repo.get_or_create_user(
				s2,
				tg_user_id=str(update.effective_user.id),
				username=update.effective_user.username,
				first_name=update.effective_user.first_name,
				last_name=update.effective_user.last_name,
			)
			repo.add_message(s2, user_id=user2.id, direction="out", type_="text", content=reply_text)


async def handle_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
	query = update.callback_query
	if not query:
		return
	await query.answer()
	data = query.data or ""
	_ephemeral_messages.setdefault(query.message.chat_id, []).append(query.message.message_id)
	if data == "menu_profile":
		await _send_ephemeral(update, context, "Ğ›Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ ĞºĞ°Ğ±Ğ¸Ğ½ĞµÑ‚ â€” ÑĞºĞ¾Ñ€Ğ¾ Ğ·Ğ´ĞµÑÑŒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ±ÑƒĞ´ĞµÑ‚ Ğ½Ğ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°Ñ‚ÑŒ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ ğŸ‘¤")
	elif data == "menu_workouts":
		await _send_ephemeral(update, context, "Ğ¢Ñ€ĞµĞ½Ğ¸Ñ€Ğ¾Ğ²ĞºĞ¸ â€” Ğ¿ĞµÑ€ÑĞ¾Ğ½Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿Ğ»Ğ°Ğ½Ñ‹ Ğ² Ñ€Ğ°Ğ·Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞµ ğŸ’ª")
	elif data == "menu_week":
		await _send_ephemeral(update, context, "ĞœĞµĞ½Ñ Ğ½Ğ° Ğ½ĞµĞ´ĞµĞ»Ñ â€” ÑĞºĞ¾Ñ€Ğ¾ Ğ¿Ğ¾Ğ´Ğ±ĞµÑ€Ñ‘Ğ¼ Ñ€Ğ°Ñ†Ğ¸Ğ¾Ğ½ Ğ¿Ğ¾Ğ´ Ñ†ĞµĞ»ÑŒ ğŸ¥—")
	elif data == "menu_ai_kbzhu_photo":
		await _send_ephemeral(update, context, "AI ĞšĞ‘Ğ–Ğ£ Ğ¿Ğ¾ Ñ„Ğ¾Ñ‚Ğ¾ â€” Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° ÑĞ½Ğ¸Ğ¼ĞºĞ° Ğ¸ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· ÑĞºĞ¾Ñ€Ğ¾ Ğ±ÑƒĞ´ÑƒÑ‚ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹ ğŸ“¸")
	elif data == "menu_support":
		await _send_ephemeral(update, context, "ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶ĞºĞ° â€” Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸ Ğ²Ğ¾Ğ¿Ñ€Ğ¾Ñ, Ğ¼Ñ‹ Ğ¿Ğ¾Ğ¼Ğ¾Ğ¶ĞµĞ¼ ğŸ†˜")
	elif data == "menu_loyalty":
		await _send_ephemeral(update, context, "Ğ‘Ğ¾Ğ½ÑƒÑĞ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ³Ñ€Ğ°Ğ¼Ğ¼Ğ° â€” ĞºĞ¾Ğ¿Ğ¸ Ğ±Ğ°Ğ»Ğ»Ñ‹ Ğ¸ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ°Ğ¹ Ğ¿Ğ»ÑÑÑ‹ ğŸ")
	else:
		await show_main_menu(update, context)


async def run() -> None:
	setup_logging(settings.log_level)
	logger = logging.getLogger("bot")
	try:
		assert_required_settings()
	except Exception as exc:
		logger.error(str(exc))
		return

	await on_startup()

	app = ApplicationBuilder().token(settings.telegram_bot_token).build()
	app.add_handler(CommandHandler("start", start_command))
	app.add_handler(CommandHandler("menu", show_main_menu))
	app.add_handler(CommandHandler("help", help_command))
	app.add_handler(CallbackQueryHandler(handle_menu_callback))
	app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
	app.add_handler(MessageHandler(filters.VOICE, handle_voice))

	logger.info("Bot is starting (polling)...")
	await app.initialize()
	await app.start()
	try:
		await app.updater.start_polling()
		await asyncio.Event().wait()
	finally:
		await app.stop()
		await app.shutdown()


if __name__ == "__main__":
	asyncio.run(run())